{"posts":[{"title":"【可穿戴柔性标签天线设计】","content":"最近课题组的研究方向已经调整为做可穿戴柔性射频前端上去了，现在有很多的小方向可以做。应该说，在东南大学这个大招牌下，我们可以集中资源去攻克这样一个问题。这样的过程，也可以看得出，科研有时候并不是做不了，要坐得住，要学得进。那就要沉下心，好好去研究。 ","link":"https://seutodaysz.github.io/wearable/"},{"title":"【数据分析 学习资料小结】","content":"网上的学习资料特别多，如何在如此众多的资料中，找到最有价值的信息来学习，我们需要听取前辈的经验，少走弯路。 如何称为一个优秀的数据分析师 职业规划 Github 职业规划 数据分析的学习资料 知乎推荐 数据集哪里找 数据集 数理基础 计算机基础 持续更新中... ","link":"https://seutodaysz.github.io/Material Data/"},{"title":"【吾日三省吾身11.6】","content":"十一月的第一周的已经过去，我又做了些什么呢？我还有什么没有做的呢？我走在什么样的道路上?我要前往什么方向呢？ 浮躁是这个时代的代名词，我想我要做一些事情开克服这样浮躁的状态 ","link":"https://seutodaysz.github.io/Thinking_11_6/"},{"title":"【图解算法—Python篇】","content":"一、 进入算法的世界 1. 什么是算法： 算法就是解决问题的具体步骤和方法。在计算机中，就是需要用有限数量来机械性或重复性的指令与计算步骤，从而解决某个具体的问题。 # 求两个整数的最大公约数 Num1 = int(input('请输入第一个整数:')) Num2 = int(input('请输入第二个整数:')) if Num1 &lt; Num2: Tmp_Num = Num1 Num1 = Num2 Num2 = Tmp_Num While Num2 !=0: Tmp_Num = Num1 % Num2 Num1 = Num2 Num2 = Tmp_Num 2. 算法的基本条件 算法特性 内容与说明 输入 0个或者多个输入数据，这些输入必须有清楚的表述和定义 输出 至少会有一个输出结果，不可以没有输出结果 明确性 每个指令或者步骤都必须是简洁明确的 有限性 在有限步骤之后，一定会结束，不会产生无限循环 有效性 步骤清楚可行，能用笔计算出来 3.描述算法复杂度的指标 3.1 时间复杂度 Big-oh 特色与说明 O(1) 常数时间，表示算法的运行时间是一个常数倍数 O(n) 线性时间，表示执行的时间随着数据集合的大小而线性增长 O(log2n) 3.2 空间复杂度 4.常见算法简介 4.1分治法 4.2 递归法 4.3 贪心法 4.4 动态规划法 4.5 迭代法 4.6 枚举法 4.7 回溯法 二、认识常用的算法 三、排序算法 四、查找和哈希算法 五、数组与链表算法 六、堆栈与队列算法 七、树形结构与算法 八、图形结构与算法 ","link":"https://seutodaysz.github.io/DataStruct/"},{"title":"【吾日三省吾身10.31】","content":" ~~最近的状态很差，昨晚不知道为啥就失眠了，凌晨三点醒来以后，就异常的清醒，然后自己还控制不住一直在玩手机。躺在床上玩手机，真是一件不需要开动脑子的事情，只需要无意识的滑动那几个软件，从中取涉取一些能够刺激我感官兴趣的东西。午夜时分，睡不着觉，开始刷手机，我现在感觉，我想是一个没有灵魂的动物，在条件反射式的寻求一些精神上的快感，刺激自己的激素分泌，在明明知道这样会导致自己第二天的精神状态很差的情况下，依然选择刷手机，这样的事情，意识到我渐渐失去了对于自己的控制力，失去了自律，失去了自己沿着自己既定目标前进的能力，结果，可是也预见的。一事无成。 ~~或许博客的作用，在这个时候开始显示出来了。我在这样时候，开始自我反省。这应该是我自我调节的重要环节。之前，可能这样的反省，只会在脑中短短停留了一会儿，其他事情的到来，就将之冲散，久而久之，我的问题并没有得到解决，反而形成了更深的习惯和条件反射，因此，我觉得，很有必要，花时间，自己把自己的问题写下来，当做是一个明智的，理智的老师，在与我进行深入的交流和反思，强化我的自律意识，也让我的生活更快的回到正轨。 ~~应该说，我近期的生活不顺畅，效率不高，我没有对其进行过一个全面的反省，或者说，也只是零星的反思，并没有形成一个系统的，全面的问题整理，但其实存在在身上的问题，已经到了不得不进行全面革新的阶段了。我的博客也搭建好了，我的新习惯，也要慢慢开始养成，今天的这一篇博文，就是一个好的开始。 我将我现在读研存在的问题归纳为三类： 1️⃣ 方向（战略） 2️⃣ 能力（战役） 3️⃣ 自律（战术） 关于选择 ~~一直以来，我就对于我的方向抱有极大的主动思考，面对方向，就要涉及到选择。一方面，人们总希望自己有尽可能多的选择。在生活中,选择也是无处不在，小到买什么东西，吃什么，大到国家走什么道路，选什么领导人。人们把拥有选择的权利作为一种神圣的权利加以捍卫，但问题又来了，既然不喜欢被安排和拘束，那么就要做出真正契合自己的选择。于是，诞生了很多优化算法，意见领袖。但其实，在我看来，这都不是一种真正意义上的选择。很多人，不愿意去思考什么样才是适合自己的，自己想要是什么？很多人更多的是借助长辈的观念，前辈的经验，甚至是排行榜的结果，但这样的选择真的是负责任的吗？毕竟选择的后果，就要由自己去承担。如果选到了不好的，会不会心有不甘?即使选到了大多数人认为合适的，又是否是真正自己追求的。这个一切的一切，都是一个及其复杂的问题。于是又回到了一个状态，一些人开始怀念没有那么多选择的时候，因为只要被动接受了这样的结果，才能沉下心去做一个学问，才能不断精进自己。因为，真正好的选择，并不是在于选择的时候，而是在于你选择以后，是如何度过的之后时光。你如何看清楚自己的喜好，对于自己的认识，是否到了足够的层次。 ~~选择是一门大学问。不同人有不同选择的方式。作为一个独立的人，我想对自己说，我和解了。我不要在纠结与过去的那个选择，我也不要去想未来会有怎么样的形态。对于过去，我想要清晰的总结出它的不足和缺点，这个是我成长的经验。也要看到自己做的好的地方，并不断保持下去。另一方面，对于未来，我要保持一种模糊的美感。一个简单的设想都足以激励我更多的精力去奋斗就好。因此，我更多的，要关注自己的当下。这也是我写博客的一个出发点。 ~~既然已经选择了，就要沉下心，好好做。 关于自律 ~~选择， 可以说是一个对于自己的认识，以及对于世界认识的一个整体的结果，才导致了我们会做出不同 的选择。但是，自律可以说是这样一种认识的具体实践。并且，自律更会形成一种正向反馈，不断形成自己向上提高的源泉。自律形成一个习惯，深化为一个思维方式和认识形态，那么，成功也必然不远了。 我觉得自己还是不够自律的。或者说我想自律，但是没有做好。 我觉得自律应该是这三个方面的，事件类型，时间安排，做事优先级，这就形成了自己的时间效率，也决定了自己的成长方式。以下具体说明： 做事安排 ：选择做什么事，什么事要加入到自己一天的安排中，这体现出自己的价值取向。比如，在个人成长方面：我要早起，我要按规律吃饭，我要减肥，我要选择有营养又管饱的食品，我要健身，我要保持自己的健康和美观， 在技术成长方面：我要学机器学习，我要学计算机，我要写文章，我要研究，这都是一种设想，这体现了自己的欲望和事情的安排，那么如何将这样的欲望统一好，合理的分配自己的精力，控制自己的欲望，我想这就是符合自己特性的时间管理。 时间管理 以前心理学讲到一个自己的兴奋点，那就是自己在什么时候，达到自己状态最好的时候， 自己什么时候状态最差，合理分配自己的事情，根据自己的作息规律和自己心理学上的精力变化曲线去改变的自己的行为方式，做最优秀的自己。 做事优先级 一个人的精力总是有限的，时间也是有限的。要做好事情的优先级安排，这样可以进一步提高自己的时间效率 ~~ ","link":"https://seutodaysz.github.io/Thinking1/"},{"title":"【Matlab 智能算法】","content":" 【1】模拟退火算法 第一部分介绍一下模拟退火算法 【1.1】概述 模拟退火算法最早是在1953年提出的，然后1983年的时候，Krikpatrick利用模拟退火算法求解了组合最优化问题。模拟退火算法是一种基于迭代求解的随机寻优算法，其出发点是物理中固体物质的退火过程与一般组合优化求解策略的相似性，其目的在于为NP难问题提供有效的近似求解方法，克服了其他算法容易陷入局部极小的缺陷和对于初值的依赖。 【1.2】原理 模拟退火算法新解的产生和接受可以分为如下的三个步骤： 🌟 由一个产生函数从当前解产生一个位于解空间的新解；为了便于后续的计算和接受，减少算法耗时，通过简单变换即可产生新解的方法。新解的变换方法决定了当前解的邻域结构。 🌟 判断新解是否会被接受，判断依据是一个接受准则，最常用的接受准则是Metropolis准则，若delta E&lt; 0,则 接受X'作为新的当前解 X；否则，以概率exp(-deltaE/T) 作为新的当前解 🌟当新解被确定接受时，用新解代替当前解，将当前解中对应于产生新解的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代，可在此基础上开始下一轮试验。若当前解被判定为舍弃，则在原当前解的基础上继续下一轮试验； 【1.3】源码 %%%%%%%%%%%%%%%%%%%%%%模拟退火算法解决函数极值%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%初始化%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clear all; %清除所有变量 close all; %清图 clc; %清屏 D=10; %变量维数 Xs=20; %上限 Xx=-20; %下限 %%%%%%%%%%%%%%%%%%%%%%%%%%%冷却表参数%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% L = 200; %马可夫链长度 K = 0.998; %衰减参数 S = 0.01; %步长因子 T=100; %初始温度 YZ = 1e-8; %容差 P = 0; %Metropolis过程中总接受点 %%%%%%%%%%%%%%%%%%%%%%%%%%随机选点 初值设定%%%%%%%%%%%%%%%%%%%%%%%%% PreX = rand(D,1)*(Xs-Xx)+Xx; PreBestX = PreX; PreX = rand(D,1)*(Xs-Xx)+Xx; BestX = PreX; %%%%%%%%%%%每迭代一次退火一次(降温), 直到满足迭代条件为止%%%%%%%%%%%% deta=abs( func1( BestX)-func1(PreBestX)); while (deta &gt; YZ) &amp;&amp; (T&gt;0.001) T=K*T; %%%%%%%%%%%%%%%%%%%%%在当前温度T下迭代次数%%%%%%%%%%%%%%%%%%%%%% for i=1:L %%%%%%%%%%%%%%%%%在此点附近随机选下一点%%%%%%%%%%%%%%%%%%%%% NextX = PreX + S* (rand(D,1) *(Xs-Xx)+Xx); %%%%%%%%%%%%%%%%%边界条件处理%%%%%%%%%%%%%%%%%%%%%%%%%% for ii=1:D if NextX(ii)&gt;Xs | NextX(ii)&lt;Xx NextX(ii)=PreX(ii) + S* (rand *(Xs-Xx)+Xx); end end %%%%%%%%%%%%%%%%%%%%%%%是否全局最优解%%%%%%%%%%%%%%%%%%%%%% if (func1(BestX) &gt; func1(NextX)) %%%%%%%%%%%%%%%%%%保留上一个最优解%%%%%%%%%%%%%%%%%%%%% PreBestX = BestX; %%%%%%%%%%%%%%%%%%%此为新的最优解%%%%%%%%%%%%%%%%%%%%%% BestX=NextX; end %%%%%%%%%%%%%%%%%%%%%%%% Metropolis过程%%%%%%%%%%%%%%%%%%% if( func1(PreX) - func1(NextX) &gt; 0 ) %%%%%%%%%%%%%%%%%%%%%%%接受新解%%%%%%%%%%%%%%%%%%%%%%%% PreX=NextX; P=P+1; else changer = -1*(func1(NextX)-func1(PreX))/ T ; p1=exp(changer); %%%%%%%%%%%%%%%%%%%%%%%%接受较差的解%%%%%%%%%%%%%%%%%%%% if p1 &gt; rand PreX=NextX; P=P+1; end end trace(P+1)=func1( BestX); end deta=abs( func1( BestX)-func1 (PreBestX)); end disp('最小值在点:'); BestX disp( '最小值为:'); func1(BestX) figure plot(trace(2:end)) xlabel('迭代次数') ylabel('目标函数值') title('适应度进化曲线') 【1.4】结果 从中可以看出 基于模拟退火算法计算的结果，很快就收敛了。 【2】粒子群算法 第二部分，介绍粒子群算法 【2.1】概述 🗒 粒子群算法最早是在1987年提出，并经过许多人的改进和努力，最终在1995年提出，并引起广泛的注意和学习。粒子群优化算法源自鸟类群体活动的规律性，模拟了鸟类觅食的原理，将鸟比作粒子，将求解问题的搜索空间比作鸟类的覅恶性空间，将寻找最优解的过程比作鸟类飞行觅食的过程，进而求解复杂的优化算法。 【2.2】原理 🗒 在粒子群算法中，每个优化问题的潜在解都是搜索空间中的一只鸟，称为粒子。所有粒子都有一个被优化的函数决定的适应度值，每个粒子都有速度和位置，然后，每个粒子就追随当前的最优粒子在解空间中搜索。 🗒 粒子群基于“种群”和“进化”的概念，通过个体间的协作和竞争，实现复杂空间的最优化解的搜索，其流程如下： ⚡️ （1）初始化粒子群，包括群体规模 N，每个粒子的位置 xi和速度 vi; ⚡️ （2）计算每个粒子的适应度值 fit[i] ⚡️ （3）对于每个粒子用它的适应度值fit[i]和个体极值pbest[i],如果fit[t] &lt;pbest[i] ,则用fit[t] 替换掉 pbest[i]； ⚡️ （4）对于每个粒子用它的适应度值fit[i]和全体极值gbest[i],如果fit[t]&lt; gbest[i],则用fit[t]替换掉gbest[i] ⚡️ （5）迭代更新每个粒子的位置xi和速度 vi;; ⚡️ （6）边界处理 ⚡️ （5）判断算法是否终止条件满足，若是，结束算法，并输出优化结果，否则，返回步骤(2) 【2.3】源码 %%%%%%%%%%%%%%%%%粒子群算法求函数极值%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%初始化%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clear all; %清除所有变量 close all; %清图 clc; %清屏 N=100; %群体粒子个数 D=10; %粒子维数 T=200; %最大迭代次数 c1=1.5; %学习因子1 c2=1.5; %学习因子2 w=0.8; %惯性权重 Xmax=20; %位置最大值 Xmin=-20; %位置最小值 Vmax=10; %速度最大值 Vmin=-10; %速度最小值 %%%%%%%%%%%%%%%%初始化种群个体（限定位置和速度）%%%%%%%%%%%%%%%% x=rand(N,D) * (Xmax-Xmin)+Xmin; v=rand(N,D) * (Vmax-Vmin)+Vmin; %%%%%%%%%%%%%%%%%%初始化个体最优位置和最优值%%%%%%%%%%%%%%%%%%% p=x; pbest=ones(N,1); for i=1:N pbest(i)=func1(x(i,:)); end %%%%%%%%%%%%%%%%%%%初始化全局最优位置和最优值%%%%%%%%%%%%%%%%%% g=ones(1,D); gbest=inf; for i=1:N if(pbest(i)&lt;gbest) g=p(i,:); gbest=pbest(i); end end gb=ones(1,T); %%%%%%%%%%%按照公式依次迭代直到满足精度或者迭代次数%%%%%%%%%%%%% for i=1:T for j=1:N %%%%%%%%%%%%%%更新个体最优位置和最优值%%%%%%%%%%%%%%%%% if (func1(x(j,:))&lt;pbest(j)) p(j,:)=x(j,:); pbest(j)=func1(x(j,:)); end %%%%%%%%%%%%%%%%更新全局最优位置和最优值%%%%%%%%%%%%%%% if(pbest(j)&lt;gbest) g=p(j,:); gbest=pbest(j); end %%%%%%%%%%%%%%%%%跟新位置和速度值%%%%%%%%%%%%%%%%%%%%% v(j,:)=w*v(j,:)+c1*rand*(p(j,:)-x(j,:))... +c2*rand*(g-x(j,:)); x(j,:)=x(j,:)+v(j,:); %%%%%%%%%%%%%%%%%%%%边界条件处理%%%%%%%%%%%%%%%%%%%%%% for ii=1:D if (v(j,ii)&gt;Vmax) | (v(j,ii)&lt; Vmin) v(j,ii)=rand * (Vmax-Vmin)+Vmin; end if (x(j,ii)&gt;Xmax) | (x(j,ii)&lt; Xmin) x(j,ii)=rand * (Xmax-Xmin)+Xmin; end end end %%%%%%%%%%%%%%%%%%%%记录历代全局最优值%%%%%%%%%%%%%%%%%%%%% gb(i)=gbest; end g; %最优个体 gb(end); %最优值 figure plot(gb) xlabel('迭代次数'); ylabel('适应度值'); title('适应度进化曲线') fun1 函数附录为： %%%%%%%%%%%%%%%%%%%适应度函数%%%%%%%%%%%%%%%%%%%% function result=func1(x) summ=sum(x.^2); result=summ; 【2.4】结果 从结果可以看出 粒子群算法在迭代50次 的时候就已经收敛了。 【3】蚁群算法 【3.1】概述 【3.2】原理 【3.3】源码 【3.4】结果 【4】遗传算法 【4.1】概述 【4.2】原理 【4.3】源码 【4.4】结果 【5】免疫算法 【5.1】概述 【5.2】原理 【5.3】源码 【5.4】结果 【6】差分进化算法 【6.1】概述 【6.2】原理 【6.3】源码 【6.4】结果 【7】禁忌搜索算法 【7.1】概述 【7.2】原理 【7.3】源码 【7.4】结果 【8】神经网络算法 【8.1】概述 【8.2】原理 【8.3】源码 【8.4】结果 ","link":"https://seutodaysz.github.io/Matlab/"},{"title":"【Markdown语法小结】","content":" Markdown 参考学习连接 Markdown公式编辑学习笔记 Cmd Markdown 公式指导手册 一、标题 在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 -------------------------------------------------------------------------- 示例： 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 -------------------------------------------------------------------------- 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 -------------------------------------------------------------------------- 示例： 这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 -------------------------------------------------------------------------- 三、引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个... -------------------------------------------------------------------------- 示例： 这是引用的内容 这是引用的内容 这是引用的内容 -------------------------------------------------------------------------- 四、分割线 有4种类型,如下所示： 效果是一样的 五、图片 ![图片alt](图片地址 ''图片title'') 说明： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接 超链接名 title可加可不加 简书 百度 七、列表 无序列表 无序列表用 - + * 任何一种都可以 示例 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表 数字加点 语法 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 八、表格 语法 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 示例 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码 语法： 单行代码：代码之间分别用一个反引号包起来 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 ","link":"https://seutodaysz.github.io/Markdown/"},{"title":"【研究生规划】厦门大学移动计算实验室","content":" 研究生阶段，要具备的能力和知识点清单如下: 👉 能力清单： 🙏 1. 自我实现的能力：明确目标、价值，能自我激励完整做事情，自我成长； 🙏 2. 科研创新的能力：大量阅读论文，总结分析，找问题并提出解决方法； 🙏 3. 动手实践的能力：超过平均水平的编程能力，独立完成实验； 🙏 4.沟通交流的能力：善于学习和沟通，会积极主动和他人沟通； 🙏 5.时间管理的能力：能合理管理自己的时间，高效做事； 🙏 6. 团队协作的能力：帮助他人，带领小组，知识分享和输出的能力 👉 知识清单： 研究生期间需要掌握的知识清单： 🏅 编程语言： ​ 精通 python，matlab，C/C++，Java； ​ 有项目经验，能独立完成实验和科研项目； 💻 操作系统和工具： ​ 熟悉Linux的部署、配置，基本命令等；（Cent OS、Ubuntu） ​ 尽量在Linux上开发和编程； ​ Linux上搭建常见应用（Apache、ftp等）； 🚀 计算机相关理论： ​ 机器学习、数据库、软件工程、大数据等基本概念； ​ 重点掌握机器学习基本原理； ​ 掌握深度学习原理； 可参考 数据分析和机器学习资料推荐 🌉 常用工具的熟练掌握： ​ 常规机器学习平台：scikit learn ​ 深度学习平台：Pytorch、TensorFlow ​ 数据处理工具包：pandas、numpy ​ 数据库：my-sql、mongodb 📄 科研和论文写作： ​ 英语能力：阅读英文论文、用英文进行论文写作的能力； ​ 论文写作类工具：Latex、Markdown；Matplotlib、Plot； 📊 大数据平台构建和数据分析 ​ 可选1-2个进行研究（如Spark、Hadoop等）； 📤 其他工具 ​ 版本控制：Git ​ 网站：WordPress、Apache、ngnix 👉 时间管理： ","link":"https://seutodaysz.github.io/StudyPlan/"},{"title":"【FPGA】基于Xilinx公司的Vivado软件进行FPGA学习","content":" 近期在做的一个科研要用到FPGA技术，在这里开一个FPGA学习的专场，对于这几年学习的数字电子技术进行一个系统的整理和梳理，以便自己后续的进一步深入掌握。 总的来说，FPGA技术是基于数字电子技术的底层开发技术，属于芯片领域的核心技术，也是国家现在被卡脖子的领域之一。对于高端的FPGA芯片，美国的封禁也难以阻挡我们向着人类智慧结晶的芯片技术发起进攻的号角。因此，要学好FPGA技术，另外复习一下数字电子技术。两者相辅相乘，才能是深入掌握了FPGA技术。 一、Xilinx公司简介 先做一个简单的介绍，参考一下百度 百度百科 Xilinx(赛灵思)是全球领先的可编程逻辑完整解决方案的供应商。Xilinx研发、制造并销售范围广泛的高级集成电路、软件设计工具以及作为预定义系统级功能的IP（Intellectual Property）核。 2018年7月18日，全球最大的可编程芯片（FPGA）厂商赛灵思宣布收购中国 AI 芯片领域的明星创业公司——深鉴科技。有“中国英伟达”之称的AI芯片初创企业将继续在其北京办公室运营。目前，交易金额及细节尚未公布。 [1] 2019年10月23日， 2019《财富》未来50强榜单公布，赛灵思（Xilinx）排名第17。 FPGA芯片的组成 1️⃣ 可编程输入输出单元； 2️⃣ 基本可编程逻辑单元； 3️⃣ 完整的时钟管理； 4️⃣ 嵌入块式RAM； 5️⃣ 丰富的布线资源； 6️⃣ 内嵌的底层功能单元和专用硬件模块； 二、Vivado 软件安装 与 使用 Vivado 下载与安装 Vivado 软件的使用 三、Veilog hdl 硬件描述语言 Verilog hdl 学习 四、Vivado软件的使用与一些入门的实验 GPIO实验 1. led点灯 module led_twinkle( input sys_clk , //系统时钟 input sys_rst_n, //系统复位，低电平有效 output [1:0] led //LED灯 ); //reg define reg [25:0] cnt ; //***************************************************** //** main code //***************************************************** //对计数器的值进行判断，以输出LED的状态 assign led = (cnt &lt; 26'd2500_0000) ? 2'b01 : 2'b10 ; //assign led = (cnt &lt; 26'd5) ? 2'b01 : 2'b10 ; //仅用于仿真 //计数器在0~5000_000之间进行计数 always @ (posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) cnt &lt;= 26'd0; else if(cnt &lt; 26'd5000_0000) // else if(cnt &lt; 26'd10) //仅用于仿真 cnt &lt;= cnt + 1'b1; else cnt &lt;= 26'd0; end endmodule 2. 按键控制 module key_led( input sys_clk , input sys_rst_n , input [1:0] key , output reg [1:0] led ); //reg define reg [24:0] cnt; reg led_ctrl; //***************************************************** //** main code //***************************************************** //1-频率计数：计数器 always @ (posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) cnt &lt;= 25'd0; else if(cnt &lt; 25'd2500_0000) //计数500ms=0.5s cnt &lt;= cnt + 1'b1; else cnt &lt;= 25'd0; end //2-状态控制：每隔500ms就更改LED的闪烁状态 always @ (posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) led_ctrl &lt;= 1'b0; else if(cnt == 25'd2500_0000) led_ctrl &lt;= ~led_ctrl; end //3-功能模块：根据按键的状态以及LED的闪烁状态来赋值LED always @ (posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) led &lt;= 2'b11; else case(key) 2'b10 : //如果按键0按下，则两个LED交替闪烁 if(led_ctrl == 1'b0) led &lt;= 2'b01; else led &lt;= 2'b10; 2'b01 : //如果按键1按下，则两个LED同时亮灭交替 if(led_ctrl == 1'b0) led &lt;= 2'b11; else led &lt;= 2'b00; 2'b11 : //如果两个按键都未按下，则两个LED都保持点亮 led &lt;= 2'b11; default: ; endcase end endmodule 3. 呼吸灯 module breath_led( input sys_clk , //时钟信号50Mhz input sys_rst_n , //复位信号 output led //LED ); //reg define reg [15:0] period_cnt ; //周期计数器频率：1khz 周期:1ms 计数值:1ms/20ns=50000 reg [15:0] duty_cycle ; //占空比数值 reg inc_dec_flag ; //0 递增 1 递减 //***************************************************** //** main code //***************************************************** //根据占空比和计数值之间的大小关系来输出LED assign led = (period_cnt &gt;= duty_cycle) ? 1'b1 : 1'b0; //周期计数器 always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) period_cnt &lt;= 16'd0; else if(period_cnt == 16'd50000) period_cnt &lt;= 16'd0; else period_cnt &lt;= period_cnt + 1'b1; end //在周期计数器的节拍下递增或递减占空比 always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) begin duty_cycle &lt;= 16'd0; inc_dec_flag &lt;= 1'b0; end else begin if(period_cnt == 16'd50000) begin //计满1ms if(inc_dec_flag == 1'b0) begin //占空比递增状态 if(duty_cycle == 16'd50000) //如果占空比已递增至最大 inc_dec_flag &lt;= 1'b1; //则占空比开始递减 else //否则占空比以25为单位递增 duty_cycle &lt;= duty_cycle + 16'd25; end else begin //占空比递减状态 if(duty_cycle == 16'd0) //如果占空比已递减至0 inc_dec_flag &lt;= 1'b0; //则占空比开始递增 else //否则占空比以25为单位递减 duty_cycle &lt;= duty_cycle - 16'd25; end end end end endmodule IP核实验 Verilog 中很重要的一种功能，就是实现了IP核的封装调用，极大提高的代码的复用效果。 五、基于FPGA的数字基带信号处理 第五部分，主要介绍设么是CRC校验位。 5.1 CRC 校验 分为以下这四部分来介绍。 5.1.1 什么是CRC校验 CRC校验码的全称是循环冗余码，是数据通信领域中最常用的一种差错校验码，其特征是信息字段和校验字段的长度可以任意选定。 这个校验方式的根本思想是在发送数据的后面拼接上一些额外的数据位，使得这个拼接之后的数据可以被一个固定的数模2整除（这里的模2整除是一种区别于普通的除法的运算方法，也不难理解），之后将数据发送……接收端同样将整个拼接后的数据与之前确定的固定的数据做模2除法，若能整除，则说明传输过程没有出错，若不能整除，则可以根据余数判断是哪一位发生了错误。、 在RFID实验中，用到的CRC校验码有2种，主要是CRC5和CRC16.这里主要是基于CRC16进行深入的介绍。 5.1.2 CRC 校验的基本原理 生成CRC码的基本原理: 任意一个由二进制位串组成的代码都可以和一个系数仅为‘0’和‘1’取值的多项式一一对应。例如：代码1010111对应的多项式为x6+x4+x2+x+1，而多项式为x5+x3+x2+x+1对应的代码101111。 标准CRC生成多项式如下表： 名称 生成多项式 简记式 CRC-4 x4+x+1 3 CRC-8 x8+x5+x4+1 0x31 CRC-8 x8+x2+x1+1 0x07 CRC-8 x8+x6+x4+x3+x2+x1 0x5E CRC-12 x12+x11+x3+x+1 80F CRC-16 x16+x15+x2+1 8005 CRC16-CCITT x16+x12+x5+1 1 021 CRC-32 x32+x26+x23+...+x2+x+1 04C11 CRC-32c x32+x28+x27+...+x8+x6+1 1EDC6F41 CRC校验是前面几段数据内容的校验值，为一个16位数据，发送时，低8位在前，高8为最后。 例如：信息字段代码为: 1011001，校验字段为：1010。 发送方：发出的传输字段为: 1 0 1 1 0 0 1 1 0 10 信息字段 校验字段 接收方：使用相同的计算方法计算出信息字段的校验码，对比接收到的实际校验码，如果相等及信息正确，不相等则信息错误；或者将接受到的所有信息除多项式，如果能够除尽，则信息正确 5.1.3 CRC校验的步骤 常用查表法和计算法。计算方法一般都是： （1）预置1个16位的寄存器为十六进制FFFF（即全为1），称此寄存器为CRC寄存器； （2）把第一个8位二进制数据（既通讯信息帧的第一个字节）与16位的CRC寄存器的低 8位相异或，把结果放于CRC寄存器，高八位数据不变； （3）把CRC寄存器的内容右移一位（朝低位）用0填补最高位，并检查右移后的移出位； （4）如果移出位为0：重复第3步（再次右移一位）；如果移出位为1，CRC寄存器与多 多项式A001（1010 0000 0000 0001）进行异或； （5）重复步骤3和4，直到右移8次，这样整个8位数据全部进行了处理； （6）重复步骤2到步骤5，进行通讯信息帧下一个字节的处理； （7）将该通讯信息帧所有字节按上述步骤计算完成后，得到的16位CRC寄存器的高、低 字节进行交换； （8）最后得到的CRC寄存器内容即为：CRC码。 5.1.4 源代码 module crc16( input sclk , input s_rst_n , input [7:0] data , output reg [15:0] out ); reg [15:0] crc16_out ; reg [15:0] crc_reg ; reg temp; integer i,j,m,n ; always @ (posedge sclk or negedge s_rst_n) begin if(s_rst_n == 1'b0) crc16_out&lt;=16'b0; else crc16_out&lt;=crc_reg; end always @ (crc16_out or data) begin crc_reg=crc16_out; for (i = 7; i &gt;= 0; i = i - 1) begin temp=data[i]^crc_reg[15]; for (j = 15; j &gt; 12; j = j - 1) begin crc_reg[j]=crc_reg[j-1]; end crc_reg[12]=temp^crc_reg[11]; for (m = 11; m &gt;5 ; m = m - 1) begin crc_reg[m]=crc_reg[m-1]; end crc_reg[5]=temp^crc_reg[4]; for (n = 4; n &gt;0 ; n = n - 1) begin crc_reg[n]=crc_reg[n-1]; end crc_reg[0]=temp^0; end out=crc_reg; end endmodule 六、基于FPGA的深度学习加速 ","link":"https://seutodaysz.github.io/FPGA/"}]}